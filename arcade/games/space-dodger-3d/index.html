<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>spacedodger3d.html</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root { --neon-blue: #00f2ff; --neon-red: #ff3131; --gold: #ffd700; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial Black', sans-serif; color: white; user-select: none; }
        
        #hud-left {
            position: absolute;
            top: 3vh;
            left: 3vh;
            width: 15vw;
            height: 15vh;
            background: rgba(10, 20, 40, 0.7);
            border: 1px solid var(--neon-blue);
            border-radius: 0.5vh;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden;
            box-shadow: 0 0 1vw rgba(0, 242, 255, 0.3);
            box-sizing: border-box;
        }
        /* Scaling the text inside HUD */
        #hud-left div {
            font-size: 1.5vw;
            white-space: nowrap;
            margin:0;
            /*flex-shrink:1;*/
        }
        #ui-user {
            font-size: 1vw !important; 
            text-overflow: ellipsis;
            overflow: hidden;
        }
        .fuel-meter { width: 100%; height: 1.5vh !important; min-height: 4px; border: 1px solid rgba(255, 255, 255, 0.3); display: flex; margin-top: 2px; background: #000; overflow: hidden; }
        .fuel-section { flex: 1; border-right: 1px solid #000; background-color: rgba(255, 255, 255, 0.05); height: 100%; box-sizing: border-box; transition: background 0.2s; }
        .fuel-section:last-child {border-right: none;}
        .siren-active .fuel-section { animation: fuel-flash 0.3s infinite alternate; }
        @keyframes fuel-flash { 0% { background: var(--neon-red); } 100% { background: #000; } }
        #hud-right {
            position: absolute;
            top: 3vh;
            right: 3vw;
            height: 10vh;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 1vw;
            z-index: 1000;
        }
        .nav-icon { width: 6vh;  height: 6vh;  border-radius: 50%; border: 1px solid #fff; display: flex; align-items: center; justify-content: center;  text-align: center; background: rgba(0,0,0,0.6); cursor: pointer; font-size: 3vh; transition: 0.3s; }
        .nav-icon:hover { transform: scale(1.1); box-shadow: 0 0 1vw var(--neon-blue); }

        .screen { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; overflow: hidden; border-radius: 0.5vh; z-index: 9999; text-align: center; pointer-events: auto; }
        .hidden { display: none !important; }
#screen-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); 
    z-index: 10000;
    display: flex;
    justify-content: center;
    align-items: flex-start; /* Changed from center so it grows downward */
    overflow-y: auto; /* The whole screen scrolls if the box is long */
    padding: 50px 0; /* Gives breathing room at top and bottom */
    border-radius: 0.5vh
}
/* Ensure the neon box fits the screen */
.neon-box { 
    padding: 1.5vh 1.5vw;
    border: 2px solid var(--neon-blue); 
    border-radius: 0.5vh; 
    background: rgba(10,10,15,0.98); 
    box-shadow: 0 0 4vh var(--neon-blue); 
    width: 80%;
    height: auto;
    margin: auto;
    display: flex;
    flex-direction: column;
    align-self: center;
    max-height: 90% /* Allows expansion */
    overflow: visible; /* Allows expansion */
}
#overlay-btns {
  display: flex;
  justify-content: center;
  gap: 1.5vh;
  flex-shrink: 0;
  padding-top: 1.5vh;
  width: 100%;
}
    
        .impact-table { width: 100%; border-collapse: collapse; margin: 1vh 0; font-size: 4vh; }
        .impact-table th { color: var(--neon-blue); border-bottom: 03vh solid var(--neon-blue); padding: 1.2vh; }
        .impact-table td { padding: 1.2vh; border-bottom: 1px solid #333; }

        .btn-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 1vh; margin-top: 2vh; }
        button { padding: 1.5vh 3.5vw; border-radius: 0.5vh; border: none; background: var(--neon-blue); color: #000; font-weight: 900; cursor: pointer; font-size: 1.5vh; text-transform: uppercase; }
        button:hover { filter: brightness(1.2); }
        .btn-alt { background: transparent; border: 2px solid var(--neon-blue); color: var(--neon-blue); }
        
/* 1. THE 3D TITLE EFFECT */
#screen-landing h1 {
    /* 9vw means the font size is exactly 9% of the screen width */
    font-size: 8vw;
    
    white-space: nowrap; 
    color: var(--neon-blue);
    font-style: italic;
    letter-spacing: 2px;
    
    /* We use 'em' for shadows so the 3D depth scales with the font size */
    text-shadow: 
        0.01em 0.01em 0px #00a8b3, 
        0.02em 0.02em 0px #00a8b3, 
        0.03em 0.03em 0px #00a8b3, 
        0.04em 0.04em 0px #00a8b3, 
        0px 0.1em 0.3em rgba(0, 242, 255, 0.6);
        
    transform: perspective(600px) rotateX(15deg);
    animation: grandFloat 3s ease-in-out infinite alternate;
    margin: 0;
}

/* Make buttons scale based on screen width */
.grand-btn {
    display: inline-block;
    padding: 1.5vh 1.5vw;
    font-size: 2.5vh;
    text-transform: uppercase;
    border: none;
    border-radius: 0.5vh;
    cursor: pointer;
    position: relative;
    transition: transform 0.1s, box-shadow 0.1s;
    z-index:9999;
    pointer-events: auto;
    /* Ensure the button doesn't 'lose' the mouse while pressing */
    touch-action: manipulation;
    /* Restore the 3D 'Ledge' */
    box-shadow: 0 0.6vw 0 rgba(0,0,0,0.5);
    flex-shrink: 0; /* Prevents button from squishing */
}
/* Specific 3D colors for buttons */
.btn-launch { background: var(--neon-blue); box-shadow: 0 1.2vh 0 #008a91; }
.btn-hof { background: var(--gold); box-shadow: 0 1.2vh 0 #8a6d00; }
.btn-back { background: var(--neon-red); box-shadow: 0 0.6vw 0 #8b0000; }

.grand-btn:active {
    transform: translateY(0.7vh);
    box-shadow: 0 0.7vh 0 rgba(0,0,0,0.5);
}
        
.grand-btn:hover {
    /* DELETE: filter: brightness(1.1); */
      opacity: 0.9;
    cursor: pointer;
}
/* 3. FLOATING ANIMATION */
@keyframes grandFloat {
    from { transform: perspective(600px) rotateX(15deg) translateY(0); }
    to { transform: perspective(600px) rotateX(20deg) translateY(-20px); }
}
/* Ensure the title shrinks to fit narrow screens */
.hof-title {
    font-size: 5vh;
    max-width: 100%;
    box-sizing: border-box;
    white-space: normal;
    overflow-wrap: break-word;
    text-align: center;
    flex-shrink: 0;
    margin: 0 0 1.5vh 0;
    color: var(--neon-blue);
    text-transform: uppercase;
    letter-spacing: 2px;
}

.manual-text {
    text-align: left;
    font-size: 1.5vw;
    line-height: 1.6;
    color: #ccc;
    margin: 2vw 0;
    font-family: 'Segoe UI', sans-serif;
}

.manual-highlight {
    color: var(--neon-blue);
    font-weight: bold;
    text-shadow: 0 0 0.5vw var(--neon-blue);
}
/* Trophy Row */
.trophy-row { width: 100%; display: flex; justify-content: center; text-align: center; font-size: 2.5vh; letter-spacing: 0.5vh; margin: 1vh 0; filter: drop-shadow(0 0 2vh var(--gold)); }

.hof-scroll-box {
    width: 100%;
    overflow: visible; /* No internal scrollbar */
    height: auto;
    margin: 5vh 0;
    flex: none; /* Box doesn't need to 'fill' space anymore */
}
/* Cleaner, neater typography */
#overlay-content {
    width: 100%
    display: flex;
    flex-direction: column;
    font-family: 'Segoe UI', sans-serif;
    font-size: 1.9vh;
    color: #eee;
}
#ui-lives {
    font-size: 1.5vh; 
    display: flex;
    gap: 2px;
    line-height: 1;
}
      
.hof-table { width: 100%; border-collapse: collapse; }
.hof-table th { font-size: 3vh; color: var(--neon-blue); border-bottom: 2px solid var(--neon-blue); padding: 1.2vh; }
.hof-table td { padding: 1vh; font-weight: bold; font-size: 1.8vh; }

/* Ranking Colors */
.rank-gold { color: var(--gold); }
.rank-silver { color: #C0C0C0; }
.rank-bronze { color: #CD7F32; }
.rank-white { color: #FFFFFF; }
    </style>
</head>
<body>

<div id="hud-left" class="hidden">
    <div id="ui-lvl">Level: 1</div>
    <div id="ui-score">Score: 0</div>
    <div id="ui-lives"></div>
    <div class="fuel-meter" id="fuel-bar-container"></div>
</div>
<div id="hud-right" class="hidden">
    <div class="nav-icon" onclick="manualTogglePause()" id="pause-btn">‚è∏Ô∏è</div>
    <div class="nav-icon" onclick="showScreen('info')">‚ÑπÔ∏è</div>
    <div class="nav-icon" onclick="toggleMute()" id="mute-btn">üîä</div>
    <div class="nav-icon" onclick="viewHOF('personal')">üèÜ</div>
    <div class="nav-icon" onclick="viewHOF('global')">üåê</div>
</div>

<div id="screen-landing" class="screen">
    <h1 id="main-title">SPACE DODGER 3D</h1>
    <div style="display: flex; flex-direction: column; align-items: center; width: 100%; margin-top: 10vh; gap: 4vh;">
    <button class="grand-btn btn-launch" onclick="console.log('CLICKED'); launchMission()">üöÄ LAUNCH MISSION</button>
    <br>
    <button class="grand-btn btn-hof" onclick="viewHOF('personal')">üèÜ PERSONAL HALL OF FAME</button>
    </div>
</div>

<div id="screen-gameover" class="screen hidden">
    <h1 style="font-size: 10vH; text-shadow: 0 0 3vw #8b0000; color: var(--neon-red); margin-bottom: 5vh;">GAME OVER</h1>
    <div class="btn-container" style="display: flex; flex-direction: column; align-items: center; gap: 3vh; width: 100%;">
        <button class="grand-btn btn-launch" onclick="launchMission()">Relaunch Mission</button>
        <button class="grand-btn btn-hof" onclick="viewHOF('personal')" class="btn-alt">View Personal High Scores</button>
    </div>
</div>

<div id="screen-overlay" class="screen hidden">
    <div id="overlay-wrapper" class="neon-box">
        <div id="overlay-content"></div>
        <div class="btn-container" id="overlay-btns">
    </div>
    </div>
</div>

<script>
let scene, camera, renderer, rocket, flame, nose;
let asteroids = [], stars = [], lasers = [], explosions = [], shakeIntensity = 0;
let score = 0, level = 1, lives = 3, fuel = 100, active = false, paused = false;
let audioCtx, engineOsc, engineGain, soundOn = true;
let whirrOsc, whirrGain;
let sirenInterval = null;
let localHOF = JSON.parse(localStorage.getItem('spaceDodgerHOF')) || [];

function setEngineState(isPlay) {
    if (!audioCtx || !engineGain) return;
    const targetVol = (isPlay && soundOn) ? 0.04 : 0;
    const whirrVol = (isPlay && soundOn) ? 0.015 : 0;
    
    engineGain.gain.setTargetAtTime(targetVol, audioCtx.currentTime, 0.1);
}    
function launchMission() {
    // INDICATE: Capture the state at the VERY TOP
    const needsToStartLoop = !active;

    // 1. WIPE OLD 3D OBJECTS
    if (scene) {
        asteroids.forEach(a => scene.remove(a));
        stars.forEach(s => scene.remove(s));
        lasers.forEach(l => scene.remove(l));
        explosions.forEach(e => scene.remove(e));
    }

    // 2. EMPTY THE ARRAYS
    asteroids = []; stars = []; lasers = []; explosions = [];
    
    // Reset core game stats
    score = 0; level = 1; lives = 3; fuel = 100;

    // Reset the button icon
    const pauseBtn = document.getElementById('pause-btn');
    if (pauseBtn) pauseBtn.innerText = '‚è∏Ô∏è';
    
    // Hide all menu overlays
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    
    // Display the game HUD
    const hudL = document.getElementById('hud-left');
    const hudR = document.getElementById('hud-right');
    if (hudL) hudL.classList.remove('hidden');
    if (hudR) hudR.classList.remove('hidden');
    
    if (!renderer) {
        init3D();
    }
    
    initAudio();
    initFuelUI();
    setEngineState(true);
    
    // INDICATE: Explicitly set states
    active = true;
    paused = false;

    // INDICATE: Start loop if it was dead
    if (needsToStartLoop) {
        animate();
    }
}
    
// Move these OUTSIDE the init3D function (Pre-define them) to save load time
const SHARED_BLUE_MAT = new THREE.MeshPhongMaterial({color: 0x0044ff});
const SHARED_RIM_MAT = new THREE.MeshPhongMaterial({color: 0xdddddd, shininess: 150, specular: 0xffffff});
const SHARED_GLASS_MAT = new THREE.MeshPhongMaterial({color: 0x111111, transparent: true, opacity: 0.8, shininess: 500, specular: 0xffffff});
    
function init3D() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const rocketGrp = new THREE.Group();
    const hull = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.45, 0.8, 32), SHARED_BLUE_MAT);
    nose = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.5, 32), SHARED_BLUE_MAT); 
    nose.position.y = 0.65;
    const engine = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.2, 0.3, 16), new THREE.MeshPhongMaterial({color: 0x222222})); engine.position.y = -0.55;
    flame = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.7, 12), new THREE.MeshBasicMaterial({color: 0xff4400})); flame.position.y = -1.0; flame.rotation.x = Math.PI;
    // --- 1. THE WINGS ---
    const wingGeo = new THREE.BoxGeometry(0.8, 0.2, 0.1); // Width, Height, Depth
    const wingMat = SHARED_BLUE_MAT;
    
    const leftWing = new THREE.Mesh(wingGeo, wingMat);
    leftWing.position.set(-0.4, -0.1, 0); // Positioned on the side of the hull
    leftWing.rotation.z = Math.PI / 4; // Angled down slightly
    
    const rightWing = new THREE.Mesh(wingGeo, wingMat);
    rightWing.position.set(0.4, -0.1, 0);
    rightWing.rotation.z = -Math.PI / 4;
    
    // --- 2. THE WINDOWS (Oval Reflective Glass with Steel Rim) ---
    const windowGrp = new THREE.Group();

    // Steel Rim (A Torus/Donut shape)
    // Parameters: radius, tube diameter, radialSegments, tubularSegments
    const rimGeo = new THREE.TorusGeometry(0.12, 0.02, 16, 32);
    const rimMat = new THREE.MeshPhongMaterial({color: 0xdddddd, shininess: 150, specular: 0xffffff});

    // Glass (A slightly flattened sphere/disc)
    const glassGeo = new THREE.SphereGeometry(0.11, 16, 16);
    const glassMat = new THREE.MeshPhongMaterial({color: 0x111111, transparent: true, opacity: 0.8, shininess: 500, specular: 0xffffff, reflectivity: 1.0});

    // Assembly of Left Window
    const leftRim = new THREE.Mesh(rimGeo, rimMat);
    const leftGlass = new THREE.Mesh(glassGeo, glassMat);
    leftGlass.scale.z = 0.2; // Flatten the sphere into an oval disc
    const leftWindow = new THREE.Group();
    leftWindow.add(leftRim, leftGlass);
    leftWindow.position.set(-0.25, 0.2, 0.1); // Placed on the side/front
    leftWindow.rotation.y = -Math.PI / 2;
    leftWindow.rotation.z = -0.35;

    // Assembly of Right Window
    const rightWindow = leftWindow.clone(); // Java-style cloning
    rightWindow.position.set(0.25, 0.2, 0.1);
    rightWindow.rotation.y = Math.PI / 2;
    rightWindow.rotation.z = 0.35;
    
    // MAIN AMBIENT LIGHT (General visibility - the "Base" light)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // DIRECTIONAL LIGHT (Like the Sun - creates shadows and depth)
    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(5, 10, 7); // Coming from top-right-front
    scene.add(sunLight);

    // THE "GLINT" LIGHT (A PointLight that follows the rocket)
    // This specifically makes the steel rims and glass shine
    const glintLight = new THREE.PointLight(0x00aaff, 1.5, 10); 
    glintLight.position.set(2, 2, 2); // Positioned to hit the windows
   
    // OPTIONAL: ENGINE GLOW (A red light at the bottom)
    const engineLight = new THREE.PointLight(0xff4400, 2, 3);
    engineLight.position.y = -1.2;
    
    // INDICATE: Add all new parts to the main group
    rocketGrp.add(hull, nose, engine, flame, leftWing, rightWing, leftWindow, rightWindow, glintLight, engineLight);
    rocket = rocketGrp; scene.add(rocket); rocket.position.y = -4;

    scene.add(new THREE.AmbientLight(0x606060));
    const sun = new THREE.DirectionalLight(0xffffff, 1); sun.position.set(5, 5, 10); scene.add(sun);
    camera.position.z = 8;
}

function initAudio() {
    if(audioCtx) audioCtx.close();
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Constant Low Frequency Rocket Whirr
    engineOsc = audioCtx.createOscillator();
    engineGain = audioCtx.createGain();
    engineOsc.type = 'sawtooth';
    engineOsc.frequency.setValueAtTime(50, audioCtx.currentTime); // Low frequency hum
    engineGain.gain.setValueAtTime(soundOn ? 0.04 : 0, audioCtx.currentTime);
    
    // Secondary Harmonic (The "Whirr")
    whirrOsc = audioCtx.createOscillator();
    whirrGain = audioCtx.createGain();
    
    whirrOsc.type = 'triangle';
    whirrOsc.frequency.setValueAtTime(110, audioCtx.currentTime);
    whirrGain.gain.setValueAtTime(soundOn ? 0.02 : 0, audioCtx.currentTime);
    
    engineOsc.connect(engineGain);
    engineGain.connect(audioCtx.destination);
    whirrOsc.connect(whirrGain);
    whirrGain.connect(audioCtx.destination);
    
    engineOsc.start();
    whirrOsc.start();
}

function playSfx(type) {
    if(!soundOn || !audioCtx) return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.connect(g); g.connect(audioCtx.destination);

    switch(type) {
        case 'impact': // A dissonant metallic crunch
            // 1. THE INITIAL SNAP (High frequency crack)
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
            g.gain.setValueAtTime(0.6, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

            // 2. THE METAL GRIND (Layered noise/grit)
            const crunchOsc = audioCtx.createOscillator();
            const crunchGain = audioCtx.createGain();
            crunchOsc.type = 'sawtooth';
            crunchOsc.frequency.setValueAtTime(150, audioCtx.currentTime);
            
            // Dissonance created by detuning
            crunchOsc.detune.setValueAtTime(Math.random() * 500, audioCtx.currentTime);
            crunchGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            crunchGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            crunchOsc.connect(crunchGain);
            crunchGain.connect(audioCtx.destination);
            crunchOsc.start();
            crunchOsc.stop(audioCtx.currentTime + 0.2);
            break;
        case 'blast': // The powerful "BLAST" logic
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(55, audioCtx.currentTime); 
            g.gain.setValueAtTime(0.7, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
            break;
        case 'booom':
            // 1. THE INITIAL PUNCH (Using existing osc/g)
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            g.gain.setValueAtTime(0.8, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

            // 2. THE SUB-BASS RUMBLE (The "BOOM")
            const subOsc = audioCtx.createOscillator();
            const subGain = audioCtx.createGain();
            subOsc.type = 'sine';
            subOsc.frequency.setValueAtTime(60, audioCtx.currentTime);
            subOsc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.8);
            subGain.gain.setValueAtTime(0.9, audioCtx.currentTime);
            subGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
            subOsc.connect(subGain); subGain.connect(audioCtx.destination);
            subOsc.start(); subOsc.stop(audioCtx.currentTime + 0.8);

            // 3. THE FIREWORK SCATTERING LOOP (The "Crackle")
            for(let i = 0; i < 20; i++) {
                const delay = 0.1 + (Math.random() * 0.4);
                const startTime = audioCtx.currentTime + delay;
        
                const pop = audioCtx.createOscillator();
                const popGain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                filter.type = "highpass";
                // Keeps the crackle crisp
                filter.frequency.value = 2000; 

                pop.type = 'square';
                pop.frequency.setValueAtTime(1200 + Math.random() * 2000, startTime);
        
                popGain.gain.setValueAtTime(0, startTime);
                popGain.gain.linearRampToValueAtTime(0.03, startTime + 0.01);
                popGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);

                pop.connect(filter);
                filter.connect(popGain);
                popGain.connect(audioCtx.destination);

                pop.start(startTime);
                pop.stop(startTime + 0.06);
            }
            break;
        case 'bling':
            osc.type = 'sine'; osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
            g.gain.setValueAtTime(0.15, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            break;
        case 'whooop':
            osc.type = 'square'; osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1400, audioCtx.currentTime + 0.5);
            g.gain.setValueAtTime(0.08, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            break;
        case 'laser':
            osc.type = 'sine'; // Removed sawtooth to prevent high-freq click
            osc.frequency.setValueAtTime(900, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.1);
            g.gain.setValueAtTime(0.04, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
            break;
        case 'siren':
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(300, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.5);
            osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 1.0);
            g.gain.setValueAtTime(0.1, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
            break;
    }
    osc.start(); osc.stop(audioCtx.currentTime + 1.0);
}

function initFuelUI() {
    const container = document.getElementById('fuel-bar-container');
    if (!container) return;
    container.innerHTML = '';
    
    // FIX: Match segments to updateUI (40) for precision**
    const segments = 40;
    for(let i=0; i < segments; i++) { 
        const s = document.createElement('div'); 
        s.className = 'fuel-section'; 
        s.style.flex = "1"; 
        s.style.height = "100%"; 
        // FIX: Add a dark base color so the empty tank is visible**
        s.style.borderRight = "1px solid #000";
        s.style.backgroundColor = "rgba(255,255,255,0.1)";
        container.appendChild(s); 
    }
}
    
function spawnLogic() {
    // 1. Asteroid Density: Increases with Level
    // Level 1 starts at 0.015, adding 0.005 per level
    let asteroidSpawnChance = 0.01 + (level * 0.005);
    if (Math.random() > asteroidSpawnChance) return;

    const minGap = 2.1; 
    let spawnX = (Math.random() - 0.5) * 12;
    
    // Spatial Gap Validation
    const existing = [...asteroids, ...stars].filter(o => o.position.y > 5);
    for(let o of existing) { 
        if(Math.abs(o.position.x - spawnX) < minGap) return; 
    }

    // 2. Star Frequency: Decreases with Level
    // Stars appear as a subset of successful spawns
    // Level 1 starts at 30% chance, Level 10 drops to 10%
    let starChance = Math.max(0.1, 0.3 - (level * 0.02));

    if(Math.random() < starChance) {
        // Create Star logic
        const star = new THREE.Mesh(new THREE.DodecahedronGeometry(0.2, 0), new THREE.MeshPhongMaterial({color: 0xffd700}));
        star.position.set(spawnX, 8, 0); 
        stars.push(star); 
        scene.add(star);
    } else {
        // Create Asteroid logic
        const s = 0.4 + Math.random() * 0.8;
        const ast = new THREE.Mesh(new THREE.DodecahedronGeometry(s, 1), new THREE.MeshPhongMaterial({color: 0x882222, flatShading: true}));
        ast.position.set(spawnX, 8, 0); 
        ast.userData = { size: s, hp: Math.ceil(s * 4) };
        asteroids.push(ast); 
        scene.add(ast);
    }
}

function createDebris(pos, size) {
    const shardCount = 8 + Math.floor(size * 10);
    for(let i=0; i < shardCount; i++) {
        const shard = new THREE.Mesh(
            // Molten Orange glow
            new THREE.BoxGeometry(0.1, 0.1, 0.1),
            new THREE.MeshStandardMaterial({color: 0x444444,emissive: 0xff4400, 
                emissiveIntensity: 2})
        );
        shard.position.copy(pos);
        // Random velocity in all directions
        shard.userData = { v: new THREE.Vector3((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3),
            life: 1.0 };
        explosions.push(shard);
        scene.add(shard);
    }
}
    
function update() {
    if(!active || paused) return;

    // CAMERA SHAKE PHYSICS
    if (shakeIntensity > 0) {
        camera.position.x += (Math.random() - 0.5) * shakeIntensity;
        camera.position.y += (Math.random() - 0.5) * shakeIntensity;
        shakeIntensity *= 0.9; // Smooth decay
        if (shakeIntensity < 0.01) shakeIntensity = 0;
    } else {
        // Return to center when not shaking
        camera.position.x = 0;
        camera.position.y = 0;
    }    
    // Update Smithereens
    explosions.forEach((p, i) => {
        p.position.add(p.userData.v);
        p.userData.life -= 0.02;
        p.scale.setScalar(p.userData.life);
        if(p.userData.life <= 0) {
            scene.remove(p);
            explosions.splice(i, 1);
        }
    });
    
    // DYNAMIC WHIRR LOGIC
    if (audioCtx && engineOsc && soundOn) {
        let targetPosX = rocket.position.x;
        // We calculate velocity by seeing how far the rocket is from its target
        let vel = Math.abs(targetPosX - (rocket.position.x || 0));
        let pitchShift = vel * 300; // How much the pitch reacts to speed
        
        engineOsc.frequency.setTargetAtTime(40 + pitchShift, audioCtx.currentTime, 0.05);
        whirrOsc.frequency.setTargetAtTime(100 + (pitchShift * 3), audioCtx.currentTime, 0.1);
    }
    const fallSpeed = 0.05 + (level * 0.02);
    flame.scale.setScalar(0.7 + Math.random() * 0.5);

    asteroids.forEach((a, i) => {
        a.position.y -= fallSpeed;
        if(a.position.distanceTo(rocket.position) < 1.1) {
            //collision
            lives--; fuel -= 15; playSfx('impact');
            // TRIGGER SHAKE: Larger asteroids cause more trauma
            shakeIntensity = 0.15 + (a.userData.size * 0.1);
            
            scene.remove(a); asteroids.splice(i,1);
        } else if(a.position.y < -6) { fuel -= 4; scene.remove(a); asteroids.splice(i,1); }
    });

    stars.forEach((s, i) => {
        s.position.y -= fallSpeed; s.rotation.z += 0.05;
        if(s.position.distanceTo(rocket.position) < 0.9) {
            score += 25; fuel = Math.min(100, fuel+5); playSfx('bling'); scene.remove(s); stars.splice(i,1);
        }
    });

    lasers.forEach((l, li) => {
        l.position.y += 0.4;
        asteroids.forEach((a, ai) => {
            if(l.position.distanceTo(a.position) < a.userData.size + 0.2) {
                a.userData.hp--; 
                scene.remove(l); 
                lasers.splice(li,1);
                createSpark(l.position);
                
                if(a.userData.hp <= 0) {
                    // 1. Remove from logic array IMMEDIATELY
                    const index = asteroids.indexOf(a);
                    if (index > -1) asteroids.splice(index, 1);   
                    createFireball(a.position, a.userData.size);
                    setTimeout(() => {
                        createDebris(a.position, a.userData.size);
                        playSfx('booom');
                        shakeIntensity = 0.15 + (a.userData.size * 0.1);
                        scene.remove(a);
                        if(a.geometry) a.geometry.dispose();
                        if(a.material) a.material.dispose();
                        
                    }, 100);
                    
                    score += a.userData.size > 0.8 ? 5 : 1; 
                    fuel = Math.min(100, fuel+2);
                    if(score >= level * 100) { level++; playSfx('whooop'); }
                } else {
                    playSfx('blast');
                }
            }
        }); // Correctly closing the asteroid loop
    }); // Correctly closing the laser loop
        if(fuel <= 0 || lives <= 0) {
        active = false; 
        if(engineOsc) engineOsc.stop();
        if (whirrOsc) whirrOsc.stop();
        
        // Check authentication state
        const isLoggedIn = !!(window.userProfile && window.userProfile.loggedIn);
        
        // 1. Identify which storage to use
        const storage = isLoggedIn ? localStorage : sessionStorage;
        const storageKey = 'spaceDodgerHOF';

        // 2. Load existing data from the chosen storage
        window.localHOF = JSON.parse(storage.getItem(storageKey)) || [];

        // 3. Push current run
        window.localHOF.push({u: 'Guest', l: level, s: score});
        window.localHOF.sort((a,b) => b.s - a.s);

        // 4. Save back to the specific storage engine
        storage.setItem(storageKey, JSON.stringify(window.localHOF));
        document.getElementById('screen-gameover').classList.remove('hidden');
    }
    spawnLogic();
    updateUI();
}

function updateUI() {
    document.getElementById('ui-lvl').innerText = "Level: " + level;
    document.getElementById('ui-score').innerText = "Score: " + score;
    document.getElementById('ui-lives').innerHTML = "‚ù§Ô∏è".repeat(lives);

    const secs = document.querySelectorAll('.fuel-section');
    // Safety check: if segments don't exist, re-init them
    if (secs.length === 0) {
        initFuelUI();
        secs = document.querySelectorAll('.fuel-section');
    }
    const fill = Math.floor((fuel/100) * secs.length);
    
    let color = (fuel < 34) ? "#ff3131" : (fuel < 67) ? "orange" : "#39ff14";
    secs.forEach((s, i) => {
        s.style.background = i < fill ? color : "#000";
        s.style.opacity = i < fill ? "1" : "0.2";
    });
    if(fuel <= 15 && active && !paused) {
       document.getElementById('fuel-bar-container').classList.add('siren-active');
       // INDICATE: Trigger audio every 1.2 seconds if not already playing
       if (!sirenInterval) {
           playSfx('siren');
            sirenInterval = setInterval(() => {
                if (fuel <= 15 && active && !paused) playSfx('siren');
                else { clearInterval(sirenInterval); sirenInterval = null; }
            }, 1200);
        }
    }
    else {
        document.getElementById('fuel-bar-container').classList.remove('siren-active');
        if (sirenInterval) { clearInterval(sirenInterval); sirenInterval = null; }
    }
}

function viewHOF(type) {
    // INDICATE: Sync memory with storage before rendering table
    const storage = (window.userProfile && window.userProfile.loggedIn) ? localStorage : sessionStorage;
    window.localHOF = JSON.parse(storage.getItem('spaceDodgerHOF')) || [];
    
    if (!window.localHOF) window.localHOF = []; // Safety check for data
    // INDICATE: Also sync Global Data reference if it doesn't exist to prevent 'undefined' crashes
    if (!window.globalHOF) window.globalHOF = [];
    
    paused = true;
    document.getElementById('pause-btn').innerText = '‚ñ∂Ô∏è';
    setEngineState(false);
    
    
    const content = document.getElementById('overlay-content');
    const btns = document.getElementById('overlay-btns');
    content.style.textAlign = 'center';
    
    btns.innerHTML = ''; 
    content.innerHTML = '';

    const isLoggedIn = !!(window.userProfile && window.userProfile.loggedIn);
    const isGuest = !isLoggedIn;
    
    const title = document.createElement('h1');
    title.className = 'hof-title';
    title.innerText = (type === 'global') ? 'GLOBAL RANKINGS' : 'PERSONAL BESTS';
    
    const trophies = document.createElement('div');
    trophies.className = 'trophy-row';
    trophies.style.fontSize = '2.5vw';
    trophies.style.margin = '0.5vw 0';
    trophies.innerText = 'üèÜ üèÜ üèÜ üèÜ üèÜ';

    const scrollBox = document.createElement('div');
    scrollBox.className = 'hof-scroll-box';
    
    if (type === 'global' && !isLoggedIn) {
        scrollBox.innerHTML = `
            <div style="text-align:center; padding:2vh; color:var(--neon-red);">
                <p>‚ö†Ô∏è ACCESS DENIED</p>
                <p>You must be logged in to view Global Rankings.</p>
            </div>`;
        
        // Create the Login Button
        const loginBtn = document.createElement('button');
        loginBtn.className = "grand-btn";
        loginBtn.style.background = "linear-gradient(to bottom, #444, #222)";
        loginBtn.innerText = "üîë MEMBER LOGIN";
        loginBtn.onclick = () => showLoginOptions('global'); // Links to the new function below
        btns.appendChild(loginBtn);
    } else {
        let tableHtml = `<table class="hof-table"><tr><th>RANK</th><th>PILOT</th><th>LVL</th><th>SCORE</th></tr>`;

        // Use global data if type is global, otherwise local
        let data = (type === 'global') ? (window.globalHOF || []) : (window.localHOF || []);

        // INDICATE: Check for empty data before slicing
        if (data.length === 0) {
            tableHtml += `<tr><td colspan="4" style="text-align:center; font-size:3vw; color:rgba(255,255, 255, 0.4);">NO MISSION DATA RECORDED</td></tr>`;
        } else {
            let displayScores = data.sort((a, b) => b.s - a.s).slice(0, 10);
            displayScores.forEach((entry, i) => {
                let rowColor = (i === 0) ? 'rank-gold' : (i === 1) ? 'rank-silver' : (i === 2) ? 'rank-bronze' : 'rank-white';
                const scoreDisplay = (entry.s !== undefined && entry.s !== null) ? entry.s.toLocaleString() : "0";
                const levelDisplay = (entry.l !== undefined) ? entry.l : "‚Äî";
                const userDisplay = entry.u || 'GUEST';
                tableHtml += `<tr class="${rowColor}" style="border-bottom: 1px solid rgba(255,255,255,0.05);">
                    <td style="opacity: 0.5; font-size: 3vh;"><center>#${i + 1}</center></td>
                    <td style="letter-spacing: 0.5vh;"><center>${userDisplay}</center></td>
                    <td style="color: var(--neon-blue); opacity: 0.8; font-size: 3vh;"><center>${levelDisplay}</center></td>
                    <td style="font-family: monospace; font-size=3vh;"><center>${scoreDisplay}</center></td>
                </tr>`;
            });
        }
        tableHtml += `</table>`;
        scrollBox.innerHTML = tableHtml;
    }
    content.appendChild(title);
    content.appendChild(trophies);
    content.appendChild(scrollBox);

    if (isGuest && type === 'personal') {
        const saveBtn = document.createElement('button');
        saveBtn.className = "grand-btn btn-launch";
        saveBtn.innerText = "üíæ SAVE SCORES";
        saveBtn.onclick = () => showLoginOptions('personal');
        btns.appendChild(saveBtn);
    }

    const backBtn = document.createElement('button');
    backBtn.className = "grand-btn btn-back";
    backBtn.innerText = "üöÄ BACK TO MISSION";
    backBtn.onclick = closeOverlay;
    btns.appendChild(backBtn);

    document.getElementById('screen-overlay').classList.remove('hidden');
}
function manualTogglePause() { paused = !paused; document.getElementById('pause-btn').innerText = paused ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è"; setEngineState(!paused);}
function toggleMute() { 
    soundOn = !soundOn; 
    document.getElementById('mute-btn').innerText = soundOn?'üîä':'üîá'; 
    setEngineState(!paused && active);
    if(engineGain) engineGain.gain.setValueAtTime(soundOn ? 0.05 : 0, audioCtx.currentTime);
}
function closeOverlay() { document.getElementById('screen-overlay').classList.add('hidden'); }
function showScreen(type) {
    paused = true;
    // INDICATE: Sync the UI button icon to show 'Play' since game is now paused
    document.getElementById('pause-btn').innerText = '‚ñ∂Ô∏è';
    setEngineState(false);
    
    const content = document.getElementById('overlay-content');
    const btns = document.getElementById('overlay-btns');
    content.innerHTML = '';
    btns.innerHTML = '';

    // Title using the fluid class we already built
    const title = document.createElement('h1');
    title.className = 'hof-title';
    title.innerText = "PILOT MANUAL";

    // Fluid Manual Body
    const textDiv = document.createElement('div');
    textDiv.className = 'manual-text';
    textDiv.innerHTML = `
        <p><span class="manual-highlight">CONTROLS:</span> Use MOUSE or TOUCH to navigate your ship.</p>
        <p><span class="manual-highlight">MISSION:</span> Avoid asteroids and collect <span style="color:var(--gold)">FUEL CELLS</span> to stay powered.</p>
        <p><span class="manual-highlight">RANKING:</span> Survival time and distance determine your place in the HOF.</p>
    `;

    content.appendChild(title);
    content.appendChild(textDiv);

    // Fluid Back Button - No hard-coded shadows/sizes!
    const backBtn = document.createElement('button');
    backBtn.className = "grand-btn btn-back";
    backBtn.innerText = "üöÄ BACK TO MISSION";
    backBtn.onclick = closeOverlay;
    btns.appendChild(backBtn);

    document.getElementById('screen-overlay').classList.remove('hidden');
}
// Function to handle the actual movement logic
function handleInput(clientX) {
    if (!active || paused) return;
    // Map screen coordinates to 3D world coordinates
    const x = (clientX / window.innerWidth) * 2 - 1;
    rocket.position.x = x * 6; // Adjust '6' to change how far the ship can move
}

// Mouse movement
window.addEventListener('mousemove', (e) => handleInput(e.clientX));

// FIX: Smooth Mobile Sliding
window.addEventListener('touchstart', (e) => {
    handleInput(e.touches[0].clientX);
}, { passive: false });

window.addEventListener('touchmove', (e) => {
     // Prevents the screen from wobbling/scrolling while playing
     e.preventDefault();
    handleInput(e.touches[0].clientX);
}, { passive: false });
    
window.addEventListener('mousedown', (e) => { 
    if(active && !paused && e.button === 0) { 
        const l = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6), new THREE.MeshBasicMaterial({color: 0x00ffff})); 
        l.position.copy(rocket.position); lasers.push(l); scene.add(l); playSfx('laser'); 
    }
});
window.addEventListener('mousemove', (e) => { if(active && !paused) rocket.position.x = (e.clientX/window.innerWidth)*14 - 7; });
function animate() { if(!active) return; requestAnimationFrame(animate); update(); renderer.render(scene, camera); }
    
function showLoginOptions(returnType) {
    const content = document.getElementById('overlay-content');
    const btns = document.getElementById('overlay-btns');
    
    // Clear previous view
    content.innerHTML = '';
    btns.innerHTML = '';

    const title = document.createElement('h1');
    title.className = 'hof-title';
    title.innerText = 'SELECT PROVIDER';
    content.appendChild(title);

    // Container for social buttons
    const loginContainer = document.createElement('div');
    loginContainer.style.display = "flex";
    loginContainer.style.flexDirection = "column";
    loginContainer.style.gap = "1.5vh";
    loginContainer.style.width = "100%";
    loginContainer.style.alignItems = "center";

    // Helper to create provider buttons
    const createProviderBtn = (name, color, icon) => {
        const btn = document.createElement('button');
        btn.className = "grand-btn";
        btn.style.width = "80%";
        btn.style.background = color;
        btn.style.boxShadow = `0 6vh 0 ${color}99`; // Slightly darker version of color
        btn.innerHTML = `${icon} LOGIN WITH ${name}`;
        btn.onclick = () => {
            console.log(`Initiating ${name} Federated Login...`);
            // Here you would link to your Firebase/Auth0/Passport.js endpoint
            // window.location.href = `/auth/${name.toLowerCase()}`;
        };
        return btn;
    };

    loginContainer.appendChild(createProviderBtn('GOOGLE', '#db4437', 'üåê'));
    loginContainer.appendChild(createProviderBtn('MICROSOFT', '#00a1f1', 'üèÅ'));
    loginContainer.appendChild(createProviderBtn('FACEBOOK', '#4267B2', 'üë•'));

    content.appendChild(loginContainer);

    // Add a Back button to return to the HOF view
    const backBtn = document.createElement('button');
    backBtn.className = "grand-btn btn-back";
    if (returnType === 'personal') {
       backBtn.innerText = "‚¨ÖÔ∏è BACK TO PERSONAL SCORES";
       backBtn.onclick = () => viewHOF('personal'); 
    } else {
        backBtn.innerText = "‚¨ÖÔ∏è BACK TO GLOBAL SCORES";
        backBtn.onclick = () => viewHOF('global'); 
    }
    btns.appendChild(backBtn);
}

function createSpark(pos) {
    const spark = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshBasicMaterial({color: 0xffffff}));
    spark.position.copy(pos);
    scene.add(spark);
    setTimeout(() => scene.remove(spark), 40);
}

function createFireball(pos, size) {
    const fire = new THREE.Mesh(new THREE.SphereGeometry(size * 0.5, 12, 12), new THREE.MeshBasicMaterial({color: 0xff6600, transparent: true, opacity: 0.8}));
    fire.position.copy(pos);
    scene.add(fire);
    let s = 1;
    const fInterval = setInterval(() => {
        s += 0.15; fire.scale.setScalar(s); fire.material.opacity -= 0.08;
        if(fire.material.opacity <= 0) { clearInterval(fInterval); scene.remove(fire); }
    }, 20);
}
</script>
</body>
</html>
